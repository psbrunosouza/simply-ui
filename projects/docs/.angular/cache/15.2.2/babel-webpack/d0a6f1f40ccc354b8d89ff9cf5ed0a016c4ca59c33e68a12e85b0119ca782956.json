{"ast":null,"code":"'use strict';\n\n// var Construct = require('es-abstract/2022/Construct');\nvar CreateRegExpStringIterator = require('es-abstract/2022/CreateRegExpStringIterator');\nvar Get = require('es-abstract/2022/Get');\nvar Set = require('es-abstract/2022/Set');\nvar SpeciesConstructor = require('es-abstract/2022/SpeciesConstructor');\nvar ToLength = require('es-abstract/2022/ToLength');\nvar ToString = require('es-abstract/2022/ToString');\nvar Type = require('es-abstract/2022/Type');\nvar flagsGetter = require('regexp.prototype.flags');\nvar callBound = require('call-bind/callBound');\nvar $indexOf = callBound('String.prototype.indexOf');\nvar OrigRegExp = RegExp;\nvar supportsConstructingWithFlags = ('flags' in RegExp.prototype);\nvar constructRegexWithFlags = function constructRegex(C, R) {\n  var matcher;\n  // workaround for older engines that lack RegExp.prototype.flags\n  var flags = 'flags' in R ? Get(R, 'flags') : ToString(flagsGetter(R));\n  if (supportsConstructingWithFlags && typeof flags === 'string') {\n    matcher = new C(R, flags);\n  } else if (C === OrigRegExp) {\n    // workaround for older engines that can not construct a RegExp with flags\n    matcher = new C(R.source, flags);\n  } else {\n    matcher = new C(R, flags);\n  }\n  return {\n    flags: flags,\n    matcher: matcher\n  };\n};\nvar regexMatchAll = function SymbolMatchAll(string) {\n  var R = this;\n  if (Type(R) !== 'Object') {\n    throw new TypeError('\"this\" value must be an Object');\n  }\n  var S = ToString(string);\n  var C = SpeciesConstructor(R, OrigRegExp);\n  var tmp = constructRegexWithFlags(C, R);\n  // var flags = ToString(Get(R, 'flags'));\n  var flags = tmp.flags;\n  // var matcher = Construct(C, [R, flags]);\n  var matcher = tmp.matcher;\n  var lastIndex = ToLength(Get(R, 'lastIndex'));\n  Set(matcher, 'lastIndex', lastIndex, true);\n  var global = $indexOf(flags, 'g') > -1;\n  var fullUnicode = $indexOf(flags, 'u') > -1;\n  return CreateRegExpStringIterator(matcher, S, global, fullUnicode);\n};\nvar defineP = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\nif (defineP && gOPD) {\n  var desc = gOPD(regexMatchAll, 'name');\n  if (desc && desc.configurable) {\n    defineP(regexMatchAll, 'name', {\n      value: '[Symbol.matchAll]'\n    });\n  }\n}\nmodule.exports = regexMatchAll;","map":{"version":3,"names":["CreateRegExpStringIterator","require","Get","Set","SpeciesConstructor","ToLength","ToString","Type","flagsGetter","callBound","$indexOf","OrigRegExp","RegExp","supportsConstructingWithFlags","prototype","constructRegexWithFlags","constructRegex","C","R","matcher","flags","source","regexMatchAll","SymbolMatchAll","string","TypeError","S","tmp","lastIndex","global","fullUnicode","defineP","Object","defineProperty","gOPD","getOwnPropertyDescriptor","desc","configurable","value","module","exports"],"sources":["/home/bruno/repos/libs/lib-y/node_modules/string.prototype.matchall/regexp-matchall.js"],"sourcesContent":["'use strict';\n\n// var Construct = require('es-abstract/2022/Construct');\nvar CreateRegExpStringIterator = require('es-abstract/2022/CreateRegExpStringIterator');\nvar Get = require('es-abstract/2022/Get');\nvar Set = require('es-abstract/2022/Set');\nvar SpeciesConstructor = require('es-abstract/2022/SpeciesConstructor');\nvar ToLength = require('es-abstract/2022/ToLength');\nvar ToString = require('es-abstract/2022/ToString');\nvar Type = require('es-abstract/2022/Type');\nvar flagsGetter = require('regexp.prototype.flags');\nvar callBound = require('call-bind/callBound');\n\nvar $indexOf = callBound('String.prototype.indexOf');\n\nvar OrigRegExp = RegExp;\n\nvar supportsConstructingWithFlags = 'flags' in RegExp.prototype;\n\nvar constructRegexWithFlags = function constructRegex(C, R) {\n\tvar matcher;\n\t// workaround for older engines that lack RegExp.prototype.flags\n\tvar flags = 'flags' in R ? Get(R, 'flags') : ToString(flagsGetter(R));\n\tif (supportsConstructingWithFlags && typeof flags === 'string') {\n\t\tmatcher = new C(R, flags);\n\t} else if (C === OrigRegExp) {\n\t\t// workaround for older engines that can not construct a RegExp with flags\n\t\tmatcher = new C(R.source, flags);\n\t} else {\n\t\tmatcher = new C(R, flags);\n\t}\n\treturn { flags: flags, matcher: matcher };\n};\n\nvar regexMatchAll = function SymbolMatchAll(string) {\n\tvar R = this;\n\tif (Type(R) !== 'Object') {\n\t\tthrow new TypeError('\"this\" value must be an Object');\n\t}\n\tvar S = ToString(string);\n\tvar C = SpeciesConstructor(R, OrigRegExp);\n\n\tvar tmp = constructRegexWithFlags(C, R);\n\t// var flags = ToString(Get(R, 'flags'));\n\tvar flags = tmp.flags;\n\t// var matcher = Construct(C, [R, flags]);\n\tvar matcher = tmp.matcher;\n\n\tvar lastIndex = ToLength(Get(R, 'lastIndex'));\n\tSet(matcher, 'lastIndex', lastIndex, true);\n\tvar global = $indexOf(flags, 'g') > -1;\n\tvar fullUnicode = $indexOf(flags, 'u') > -1;\n\treturn CreateRegExpStringIterator(matcher, S, global, fullUnicode);\n};\n\nvar defineP = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nif (defineP && gOPD) {\n\tvar desc = gOPD(regexMatchAll, 'name');\n\tif (desc && desc.configurable) {\n\t\tdefineP(regexMatchAll, 'name', { value: '[Symbol.matchAll]' });\n\t}\n}\n\nmodule.exports = regexMatchAll;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA,IAAIA,0BAA0B,GAAGC,OAAO,CAAC,6CAA6C,CAAC;AACvF,IAAIC,GAAG,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AACzC,IAAIE,GAAG,GAAGF,OAAO,CAAC,sBAAsB,CAAC;AACzC,IAAIG,kBAAkB,GAAGH,OAAO,CAAC,qCAAqC,CAAC;AACvE,IAAII,QAAQ,GAAGJ,OAAO,CAAC,2BAA2B,CAAC;AACnD,IAAIK,QAAQ,GAAGL,OAAO,CAAC,2BAA2B,CAAC;AACnD,IAAIM,IAAI,GAAGN,OAAO,CAAC,uBAAuB,CAAC;AAC3C,IAAIO,WAAW,GAAGP,OAAO,CAAC,wBAAwB,CAAC;AACnD,IAAIQ,SAAS,GAAGR,OAAO,CAAC,qBAAqB,CAAC;AAE9C,IAAIS,QAAQ,GAAGD,SAAS,CAAC,0BAA0B,CAAC;AAEpD,IAAIE,UAAU,GAAGC,MAAM;AAEvB,IAAIC,6BAA6B,IAAG,OAAO,IAAID,MAAM,CAACE,SAAS;AAE/D,IAAIC,uBAAuB,GAAG,SAASC,cAAc,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC3D,IAAIC,OAAO;EACX;EACA,IAAIC,KAAK,GAAG,OAAO,IAAIF,CAAC,GAAGhB,GAAG,CAACgB,CAAC,EAAE,OAAO,CAAC,GAAGZ,QAAQ,CAACE,WAAW,CAACU,CAAC,CAAC,CAAC;EACrE,IAAIL,6BAA6B,IAAI,OAAOO,KAAK,KAAK,QAAQ,EAAE;IAC/DD,OAAO,GAAG,IAAIF,CAAC,CAACC,CAAC,EAAEE,KAAK,CAAC;EAC1B,CAAC,MAAM,IAAIH,CAAC,KAAKN,UAAU,EAAE;IAC5B;IACAQ,OAAO,GAAG,IAAIF,CAAC,CAACC,CAAC,CAACG,MAAM,EAAED,KAAK,CAAC;EACjC,CAAC,MAAM;IACND,OAAO,GAAG,IAAIF,CAAC,CAACC,CAAC,EAAEE,KAAK,CAAC;EAC1B;EACA,OAAO;IAAEA,KAAK,EAAEA,KAAK;IAAED,OAAO,EAAEA;EAAQ,CAAC;AAC1C,CAAC;AAED,IAAIG,aAAa,GAAG,SAASC,cAAc,CAACC,MAAM,EAAE;EACnD,IAAIN,CAAC,GAAG,IAAI;EACZ,IAAIX,IAAI,CAACW,CAAC,CAAC,KAAK,QAAQ,EAAE;IACzB,MAAM,IAAIO,SAAS,CAAC,gCAAgC,CAAC;EACtD;EACA,IAAIC,CAAC,GAAGpB,QAAQ,CAACkB,MAAM,CAAC;EACxB,IAAIP,CAAC,GAAGb,kBAAkB,CAACc,CAAC,EAAEP,UAAU,CAAC;EAEzC,IAAIgB,GAAG,GAAGZ,uBAAuB,CAACE,CAAC,EAAEC,CAAC,CAAC;EACvC;EACA,IAAIE,KAAK,GAAGO,GAAG,CAACP,KAAK;EACrB;EACA,IAAID,OAAO,GAAGQ,GAAG,CAACR,OAAO;EAEzB,IAAIS,SAAS,GAAGvB,QAAQ,CAACH,GAAG,CAACgB,CAAC,EAAE,WAAW,CAAC,CAAC;EAC7Cf,GAAG,CAACgB,OAAO,EAAE,WAAW,EAAES,SAAS,EAAE,IAAI,CAAC;EAC1C,IAAIC,MAAM,GAAGnB,QAAQ,CAACU,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;EACtC,IAAIU,WAAW,GAAGpB,QAAQ,CAACU,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;EAC3C,OAAOpB,0BAA0B,CAACmB,OAAO,EAAEO,CAAC,EAAEG,MAAM,EAAEC,WAAW,CAAC;AACnE,CAAC;AAED,IAAIC,OAAO,GAAGC,MAAM,CAACC,cAAc;AACnC,IAAIC,IAAI,GAAGF,MAAM,CAACG,wBAAwB;AAE1C,IAAIJ,OAAO,IAAIG,IAAI,EAAE;EACpB,IAAIE,IAAI,GAAGF,IAAI,CAACZ,aAAa,EAAE,MAAM,CAAC;EACtC,IAAIc,IAAI,IAAIA,IAAI,CAACC,YAAY,EAAE;IAC9BN,OAAO,CAACT,aAAa,EAAE,MAAM,EAAE;MAAEgB,KAAK,EAAE;IAAoB,CAAC,CAAC;EAC/D;AACD;AAEAC,MAAM,CAACC,OAAO,GAAGlB,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}