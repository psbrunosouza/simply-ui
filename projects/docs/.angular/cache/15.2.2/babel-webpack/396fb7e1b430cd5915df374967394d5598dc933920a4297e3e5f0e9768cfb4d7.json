{"ast":null,"code":"\"use strict\";\n\nrequire(\"/home/bruno/repos/libs/lib-y/node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paste = paste;\nvar _dom = require(\"@testing-library/dom\");\nvar _utils = require(\"./utils\");\nfunction isSupportedElement(element) {\n  return (0, _utils.isElementType)(element, 'input') && Boolean(_utils.editableInputTypes[element.type]) || (0, _utils.isElementType)(element, 'textarea');\n}\nfunction paste(element, text, init) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n    initialSelectionStart = _ref.initialSelectionStart,\n    initialSelectionEnd = _ref.initialSelectionEnd;\n  // TODO: implement for contenteditable\n  if (!isSupportedElement(element)) {\n    throw new TypeError(`The given ${element.tagName} element is currently unsupported.\n      A PR extending this implementation would be very much welcome at https://github.com/testing-library/user-event`);\n  }\n  if ((0, _utils.isDisabled)(element)) {\n    return;\n  }\n  (0, _utils.eventWrapper)(function () {\n    return element.focus();\n  }); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"paste\", they expect it to paste\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n  if (element.selectionStart === 0 && element.selectionEnd === 0) {\n    (0, _utils.setSelectionRange)(element, initialSelectionStart != null ? initialSelectionStart : element.value.length, initialSelectionEnd != null ? initialSelectionEnd : element.value.length);\n  }\n  _dom.fireEvent.paste(element, init);\n  if (element.readOnly) {\n    return;\n  }\n  text = text.substr(0, (0, _utils.getSpaceUntilMaxLength)(element));\n  var _ref2 = (0, _utils.calculateNewValue)(text, element),\n    newValue = _ref2.newValue,\n    newSelectionStart = _ref2.newSelectionStart;\n  _dom.fireEvent.input(element, {\n    inputType: 'insertFromPaste',\n    target: {\n      value: newValue\n    }\n  });\n  (0, _utils.setSelectionRange)(element,\n  // TODO: investigate why the selection caused by invalid parameters was expected\n  {\n    newSelectionStart: newSelectionStart,\n    selectionEnd: newSelectionStart\n  }, {});\n}","map":{"version":3,"mappings":"AAAA,YAAY;;AAACA;AAEbC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,KAAK,GAAGA,KAAK;AAErB,IAAIC,IAAI,GAAGN,OAAO,CAAC,sBAAsB,CAAC;AAE1C,IAAIO,MAAM,GAAGP,OAAO,CAAC,SAAS,CAAC;AAE/B,SAASQ,kBAAkBA,CAACC,OAAO,EAAE;EACnC,OAAO,CAAC,CAAC,EAAEF,MAAM,CAACG,aAAa,EAAED,OAAO,EAAE,OAAO,CAAC,IAAIE,OAAO,CAACJ,MAAM,CAACK,kBAAkB,CAACH,OAAO,CAACI,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEN,MAAM,CAACG,aAAa,EAAED,OAAO,EAAE,UAAU,CAAC;AAC1J;AAEA,SAASJ,KAAKA,CAACI,OAAO,EAAEK,IAAI,EAAEC,IAAI,EAG1B;EAAA,+EAAJ,CAAC,CAAC;IAFJC,qBAAqB,QAArBA,qBAAqB;IACrBC,mBAAmB,QAAnBA,mBAAmB;EAEnB;EACA,IAAI,CAACT,kBAAkB,CAACC,OAAO,CAAC,EAAE;IAChC,MAAM,IAAIS,SAAS,CAAE,aAAYT,OAAO,CAACU,OAAQ;AACrD,qHAAqH,CAAC;EACpH;EAEA,IAAI,CAAC,CAAC,EAAEZ,MAAM,CAACa,UAAU,EAAEX,OAAO,CAAC,EAAE;IACnC;EACF;EAEA,CAAC,CAAC,EAAEF,MAAM,CAACc,YAAY,EAAE;IAAA,OAAMZ,OAAO,CAACa,KAAK,EAAE;EAAA,EAAC,CAAC,CAAC;EACjD;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAIb,OAAO,CAACc,cAAc,KAAK,CAAC,IAAId,OAAO,CAACe,YAAY,KAAK,CAAC,EAAE;IAC9D,CAAC,CAAC,EAAEjB,MAAM,CAACkB,iBAAiB,EAAEhB,OAAO,EAAEO,qBAAqB,IAAI,IAAI,GAAGA,qBAAqB,GAAGP,OAAO,CAACL,KAAK,CAACsB,MAAM,EAAET,mBAAmB,IAAI,IAAI,GAAGA,mBAAmB,GAAGR,OAAO,CAACL,KAAK,CAACsB,MAAM,CAAC;EAChM;EAEApB,IAAI,CAACqB,SAAS,CAACtB,KAAK,CAACI,OAAO,EAAEM,IAAI,CAAC;EAEnC,IAAIN,OAAO,CAACmB,QAAQ,EAAE;IACpB;EACF;EAEAd,IAAI,GAAGA,IAAI,CAACe,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEtB,MAAM,CAACuB,sBAAsB,EAAErB,OAAO,CAAC,CAAC;EAClE,YAGI,CAAC,CAAC,EAAEF,MAAM,CAACwB,iBAAiB,EAAEjB,IAAI,EAAEL,OAAO,CAAC;IAF9CuB,QAAQ,SAARA,QAAQ;IACRC,iBAAiB,SAAjBA,iBAAiB;EAGnB3B,IAAI,CAACqB,SAAS,CAACO,KAAK,CAACzB,OAAO,EAAE;IAC5B0B,SAAS,EAAE,iBAAiB;IAC5BC,MAAM,EAAE;MACNhC,KAAK,EAAE4B;IACT;EACF,CAAC,CAAC;EAEF,CAAC,CAAC,EAAEzB,MAAM,CAACkB,iBAAiB,EAAEhB,OAAO;EAAE;EACvC;IACEwB,iBAAiB,EAAjBA,iBAAiB;IACjBT,YAAY,EAAES;EAChB,CAAC,EAAE,CAAC,CAAC,CAAC;AACR","names":["require","Object","defineProperty","exports","value","paste","_dom","_utils","isSupportedElement","element","isElementType","Boolean","editableInputTypes","type","text","init","initialSelectionStart","initialSelectionEnd","TypeError","tagName","isDisabled","eventWrapper","focus","selectionStart","selectionEnd","setSelectionRange","length","fireEvent","readOnly","substr","getSpaceUntilMaxLength","calculateNewValue","newValue","newSelectionStart","input","inputType","target"],"sources":["/home/bruno/repos/libs/lib-y/node_modules/@testing-library/user-event/dist/paste.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paste = paste;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _utils = require(\"./utils\");\n\nfunction isSupportedElement(element) {\n  return (0, _utils.isElementType)(element, 'input') && Boolean(_utils.editableInputTypes[element.type]) || (0, _utils.isElementType)(element, 'textarea');\n}\n\nfunction paste(element, text, init, {\n  initialSelectionStart,\n  initialSelectionEnd\n} = {}) {\n  // TODO: implement for contenteditable\n  if (!isSupportedElement(element)) {\n    throw new TypeError(`The given ${element.tagName} element is currently unsupported.\n      A PR extending this implementation would be very much welcome at https://github.com/testing-library/user-event`);\n  }\n\n  if ((0, _utils.isDisabled)(element)) {\n    return;\n  }\n\n  (0, _utils.eventWrapper)(() => element.focus()); // by default, a new element has it's selection start and end at 0\n  // but most of the time when people call \"paste\", they expect it to paste\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitely start typing with the cursor at 0. Not super common.\n\n  if (element.selectionStart === 0 && element.selectionEnd === 0) {\n    (0, _utils.setSelectionRange)(element, initialSelectionStart != null ? initialSelectionStart : element.value.length, initialSelectionEnd != null ? initialSelectionEnd : element.value.length);\n  }\n\n  _dom.fireEvent.paste(element, init);\n\n  if (element.readOnly) {\n    return;\n  }\n\n  text = text.substr(0, (0, _utils.getSpaceUntilMaxLength)(element));\n  const {\n    newValue,\n    newSelectionStart\n  } = (0, _utils.calculateNewValue)(text, element);\n\n  _dom.fireEvent.input(element, {\n    inputType: 'insertFromPaste',\n    target: {\n      value: newValue\n    }\n  });\n\n  (0, _utils.setSelectionRange)(element, // TODO: investigate why the selection caused by invalid parameters was expected\n  {\n    newSelectionStart,\n    selectionEnd: newSelectionStart\n  }, {});\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}