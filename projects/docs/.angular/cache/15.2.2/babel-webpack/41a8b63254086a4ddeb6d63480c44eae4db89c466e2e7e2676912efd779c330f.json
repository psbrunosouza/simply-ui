{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar getGlobalSymbolDescription = GetIntrinsic('%Symbol.keyFor%', true);\nvar thisSymbolValue = callBound('%Symbol.prototype.valueOf%', true);\nvar symToStr = callBound('Symbol.prototype.toString', true);\nvar getInferredName = require('./getInferredName');\n\n/* eslint-disable consistent-return */\nmodule.exports = callBound('%Symbol.prototype.description%', true) || function getSymbolDescription(symbol) {\n  if (!thisSymbolValue) {\n    throw new $SyntaxError('Symbols are not supported in this environment');\n  }\n\n  // will throw if not a symbol primitive or wrapper object\n  var sym = thisSymbolValue(symbol);\n  if (getInferredName) {\n    var name = getInferredName(sym);\n    if (name === '') {\n      return;\n    }\n    return name.slice(1, -1); // name.slice('['.length, -']'.length);\n  }\n\n  var desc;\n  if (getGlobalSymbolDescription) {\n    desc = getGlobalSymbolDescription(sym);\n    if (typeof desc === 'string') {\n      return desc;\n    }\n  }\n  desc = symToStr(sym).slice(7, -1); // str.slice('Symbol('.length, -')'.length);\n  if (desc) {\n    return desc;\n  }\n};","map":{"version":3,"names":["GetIntrinsic","require","callBound","$SyntaxError","getGlobalSymbolDescription","thisSymbolValue","symToStr","getInferredName","module","exports","getSymbolDescription","symbol","sym","name","slice","desc"],"sources":["/home/bruno/repos/libs/lib-y/node_modules/get-symbol-description/index.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bind/callBound');\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar getGlobalSymbolDescription = GetIntrinsic('%Symbol.keyFor%', true);\nvar thisSymbolValue = callBound('%Symbol.prototype.valueOf%', true);\nvar symToStr = callBound('Symbol.prototype.toString', true);\n\nvar getInferredName = require('./getInferredName');\n\n/* eslint-disable consistent-return */\nmodule.exports = callBound('%Symbol.prototype.description%', true) || function getSymbolDescription(symbol) {\n\tif (!thisSymbolValue) {\n\t\tthrow new $SyntaxError('Symbols are not supported in this environment');\n\t}\n\n\t// will throw if not a symbol primitive or wrapper object\n\tvar sym = thisSymbolValue(symbol);\n\n\tif (getInferredName) {\n\t\tvar name = getInferredName(sym);\n\t\tif (name === '') {\n\t\t\treturn;\n\t\t}\n\t\treturn name.slice(1, -1); // name.slice('['.length, -']'.length);\n\t}\n\n\tvar desc;\n\tif (getGlobalSymbolDescription) {\n\t\tdesc = getGlobalSymbolDescription(sym);\n\t\tif (typeof desc === 'string') {\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\tdesc = symToStr(sym).slice(7, -1); // str.slice('Symbol('.length, -')'.length);\n\tif (desc) {\n\t\treturn desc;\n\t}\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAE3C,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAE9C,IAAIE,YAAY,GAAGH,YAAY,CAAC,eAAe,CAAC;AAChD,IAAII,0BAA0B,GAAGJ,YAAY,CAAC,iBAAiB,EAAE,IAAI,CAAC;AACtE,IAAIK,eAAe,GAAGH,SAAS,CAAC,4BAA4B,EAAE,IAAI,CAAC;AACnE,IAAII,QAAQ,GAAGJ,SAAS,CAAC,2BAA2B,EAAE,IAAI,CAAC;AAE3D,IAAIK,eAAe,GAAGN,OAAO,CAAC,mBAAmB,CAAC;;AAElD;AACAO,MAAM,CAACC,OAAO,GAAGP,SAAS,CAAC,gCAAgC,EAAE,IAAI,CAAC,IAAI,SAASQ,oBAAoB,CAACC,MAAM,EAAE;EAC3G,IAAI,CAACN,eAAe,EAAE;IACrB,MAAM,IAAIF,YAAY,CAAC,+CAA+C,CAAC;EACxE;;EAEA;EACA,IAAIS,GAAG,GAAGP,eAAe,CAACM,MAAM,CAAC;EAEjC,IAAIJ,eAAe,EAAE;IACpB,IAAIM,IAAI,GAAGN,eAAe,CAACK,GAAG,CAAC;IAC/B,IAAIC,IAAI,KAAK,EAAE,EAAE;MAChB;IACD;IACA,OAAOA,IAAI,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EAC3B;;EAEA,IAAIC,IAAI;EACR,IAAIX,0BAA0B,EAAE;IAC/BW,IAAI,GAAGX,0BAA0B,CAACQ,GAAG,CAAC;IACtC,IAAI,OAAOG,IAAI,KAAK,QAAQ,EAAE;MAC7B,OAAOA,IAAI;IACZ;EACD;EAEAA,IAAI,GAAGT,QAAQ,CAACM,GAAG,CAAC,CAACE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACnC,IAAIC,IAAI,EAAE;IACT,OAAOA,IAAI;EACZ;AACD,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}